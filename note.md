leetcode537:
①初始化字符串：char * res = (char *)malloc(sizeof(char) * 20);
这里res是字符串的指针，指向字符串第一个字符，这个字符串是最多有20个char字符，所以使用malloc为其分配空间
然后使用(char *)将其强制转换成char的指针类型
②官方题解：
bool parseComplexNumber(const char * num, int * real, int * image) {
    char *token = strtok(num, "+");
    *real = atoi(token);
    token = strtok(NULL, "i");
    *image = atoi(token);
    return true;
};
这里的strtok函数char *strtok(char s[], const char *delim);传入一个字符串和字符用于分割字符串
int atoi (const char * str);可以将扫描这个字符串，然后将遇到的数字（包括正负号）转换为整型变量

leetcode592:
①辗转相除法来求最大公约数
long long gcd(long long a, long long b) {
    long remainder = a % b;
    while (remainder != 0) {
        a = b;
        b = remainder;
        remainder = a % b;
    }
    return b;
}
如何求最小公倍数？a*b/c即为最小公倍数，不过需要先求出最大公约数。

leetcode640:
①这里对这个方程分析有两处需要注意的地方，一是对方程左右两边的数据处理，通过左边默认系数1，右侧默认系数-1来实现
第二是对x前的系数来分析，由于x前的是被省略的，所以我们在读取数字的时候可以通过判断是否有数字，即程序中的valid值来判断x的系数

leetcode557：
①我们对字符串进行空间分配的时候需要在已知的length上+1，这不仅可以作为安全的容量，并且还要作为字符串结束的表示'\0'放置的位置
②本题需要对字符串里的每个单词部分进行反转，这里可以通过维护i，start，p三个变量来实现，i用于记录在整个大的字符串中遍历到的位置
start等于i的位置，如果后续读到的不是空格那么就继续对i自增，start不动，当读到空格就开始遍历当前这个单词即可。

leetcode392:
采用双指针同时遍历目标字符串和原字符串，判断结束的标志是如果子字符串在原字符串找到了，那么才移动子字符串的指针，最后判别子字符串的指针是否到达最后一位即可。

leetcode521:最长特殊序列Ⅰ
没什么好说的，脑袋抽了，直接使用了strcmp，来判断字符串，这里是逐个字符比较大小，返回的是当前比较到的字符ascil码大小关系。

leetcode524:
思路
和leetcode392很像，先找到符合要求的字符串，然后比较他们谁的长度最长，对于长度一样的使用strcmp就可以比较字典序的大小了。
解题方法
初次看到这个题目，和leetcode的392题目很像，将一个字符串换成了多个字符串，所以就把他当稍微复杂一点的392题做了，结果发现报错了。因为第一遍的代码自己没有处理字典序的问题，所以导致对于"abe"和"abc"应该返回后者，但是我返回了前者。
这里我们首先把leetcode392题的代码敲进去，写成check函数，可见下方代码。然后就是一个简单的比较符合check函数字符串的长度以及相关条件的代码。在对代码多次分析修改之后，发现只要在对于符合check要求的字符串比较时规定以下的规则：①优先转换为更长的符合要求字符串②如果字符串长度一样，那么直接在这里使用strcmp比较字典序就可以了。


leetcode522:
这个题目有点类比于冒泡排序，对于每个字符串都要和字典里其他的字符串比较，并且对于符合check条件的字符串找最长的那个


leetcode482:
这个题需要将字符串里的非-字符提取出来，然后按照它所要求的格式输出，从后往前每k个添加-。
我自己写的思路就是纯纯的模拟，主打一个暴力模拟，在书写的时候要考虑到如果没有非-字符需要直接返回“”
更好的方法是使用倒置，首先获取你需要考虑的非-字符，然后倒序输入进结果字符串中，每k个就添加一个-即可。这样更容易实现，代码更加简洁。


leetcode686:
还是字符串的相关函数了解不多，并且还有C语言关于内存的函数。比如strstr是在a中查找b字符串第一次出现的位置，即最后返回的是地址，可以这样来查看是否有子字符串这样的想法。还有memset以及malloc函数。这些都是平时自己用的少，但是却很重要的函数。

leetcode459:
我觉得这里最精妙的就是s[j] != s[j-i]这个比较方法，这里是以第一个单位字符串为基准，第二个和第一个一样，那就再比较第三个和第二个，有一点递推的感觉。


leetcode214:
这个题目需要从右往左找回文串的中心位置，也就是说要从右往左找符合回文串的字符串内容，然后把这个字符串右边的需要复制过去的内容复制进答案中，最后把原字符串使用strcat追加到ret答案字符串中就可以了。


leetcode342：
method1
//对于4的幂，我们可以有以下的想法:
//4的n次方为(3+1)的n次方，通过二项式展开可以知道，这个幂%3 一定剩下1
//所以我们可以先判断这个数，是不是2的幂数，是的话再判断是不是%3 == 1
method2  记得C语言中写十六位进制是由0x，二进制是有0b的
//在leetcode231中我们学会了如何判断2的幂
//2和4的区别在于二进制下，4的幂中它的1只出现在奇数位，所以我们去判断对于所有的2的幂
//判断它的1是否出现在了偶数位也可以，如果有的话按位与最后的结果非零

leetcode504:
转换为不同进制这里的主要原理就是，从右往左每一位都是该进制下的对应次数。例如10的0次方，10的1次方等等。
我们如何把十进制数转为我们需要的进制，例如七进制。主要一开始的想法是，从大到小开始转，
但其实可以不用这样，很麻烦，你要确定这里对应的最大的位数是多少。
所以我们这里可以转换思想，从小到大，反转来处理。
我们首先逐次%7，确定了0位上的，然后将这个数/7，这样可以去掉已经确定位数的值，然后再%7，
就可以得到下一位的数值，这样反复处理直到num≤0就停止循环就可以了。
对于负号的处理，我们只需要在反转之前把-添到字符串最后面，最后一起反转就可以了。
这里写一下反转字符串的代码：
void* reverse(char* s){//因为直接把字符串指针引入函数了，不需要再返回其他的了。
    int length = strlen(s);
    for(int i = 0; i < length / 2; i++){
        char swap = s[i];
        s[i] = s[length - i - i];
        s[length - i - i] = swap;
    }
}

leetcode263:
这里需要注意的是因为我们需要找完所有的质因数，所以这里需要对2，3，5需要找完，采用while，对每个质因数都使用while找完，而不是分别使用if来处理。否则的话除法次数太多了会有陷入死循环的结果。并且1也算做符合要求的丑数。

leetcode191:
二进制的每一位对应的2的每一个次方，逐个比较是否为1就可以了

leetcode50:
快速幂，如果每次只乘一次的话循环时间会很慢。对于次数而言，我们可以想办法让其乘的次数少一点。比如我们可以每次乘以x²来加快乘法计算的时间，或者采用更大的分解来减少乘法的次数。


leetcode682:
这里唯一的问题就是我们要处理好的就是操作数，因为这里给的字符串数组的形式，
我们需要使用isdigit和atoi这种函数来辅助判断这个数的值，并且传给我们所定义的record数组中

leetcode71:
这里我们需要将输入的路径进行简化，对于.. 和 .，我们可以使用栈来处理，由于这个路径是涉及到了先进后出的性质。
所以我们可以先将路径中的非/部分转换成元素为字符串的一个数组，然后在主要的函数中来处理这数组里的内容即可。


leetcode150:
这道题有点像数据结构书中的后缀表达式了，不过这里没有涉及到括号这一部分的内容。
我们这个题目只需要处理的两个部分：一是将字符串分出来然后转换成数字，这里也包括有负号的；
二是对于操作符，我们需要取出栈里的最顶上两个数计算，计算完还要返回。
在处理计算中我们需要分清楚，是先进栈的那个数作为了被操作数，后进栈的数是操作数。
我们如果需要判断一个字符串s是数还是- * / +，可以如下函数来判断：
bool isNumber(char* s){
    if(strlen(s) == 1){
        if(s[0] >= '0' && s[0] <= '9'){
            return true;
        }
        else{
            return false;
        }
    }
    return true;
}
后续我们对于isNumber是true的直接使用atoi来转换成数即可。

leetcode636:
这道题对于每个开始的任务都会有一个对应的end来结束，并且发现，必须要结束最新开始的任务，
才能继续结束之前的任务。所以这里我们可以使用栈的思想来进行算法的编写。
这里处理栈需要关注的问题是，我们在栈里需要保存什么样的数据。
由于我们需要保存任务的编号以及相关的时间，所以我们需要保存人物的编号以及对应的开始时间。
这里我们可以创建一个结构体来保存这些，这样在栈空间分配的时候会稍微简单一点。
对于每个start的字符串我们入栈，遇到end的字符串，我们首先要记录当前这个任务的时长，并且将这个时长写入最后的答案数组中就可以了。


leetcode32:
在这段代码中，将栈底初始化为-1是为了处理某些特定情况，使得计算最长有效括号子串的长度更加简便。具体来说，初始化栈底为-1有以下几个原因：
1. **方便计算长度**：
    - 当找到一个匹配的右括号时，`maxans` 的值将更新为当前索引 `i` 减去栈顶索引 `stk[top]` 的差值。这种情况下，如果栈底是-1，那么当第一个有效括号序列结束时，长度计算为 `i - (-1)`，即 `i + 1`，这正是第一个有效括号序列的长度。
2. **处理边界情况**：
    - 如果栈底是-1，当我们遇到一个不匹配的右括号（即栈为空时），我们会将当前索引 `i` 推入栈中。这允许我们在之后的匹配中正确计算新的有效括号序列的起始位置。
3. **保证栈永不为空**：
    - 栈底为-1可以保证栈在任何时候都不会为空，避免了栈操作中的异常情况（例如栈下溢）
通过在栈底放置-1，代码简化了最长有效括号序列长度的计算逻辑，并正确处理边界情况。


leetcode203:
这道题的头节点head表示的是链表中的第一个结点内容，也就是说可能头节点我们也需要删除掉。
所以这里我们可以创建一个指针并且赋予空间指向第一个head结点，之后我们使用temp来遍历链表删除对应的结点即可。


leetcode237:
这个题目给出你需要删除的结点的指针，而且没有头节点，所以不能通过遍历链表来实现删除。
我们可以通过将node节点的下一个结点指针赋值到node，将node的指向下一个结点改为指向下下一个结点就可以了

leetcode19:
这里处理的要点是，head头节点是链表中的元素，所以需要一个dum来作为头节点方便链表操作。
再就是由于链表原有的head结点可能会被删除，所以这里我们需要创建一个新的头节点newhead并且newhead=dum->next
这样我们就可以正常返回了

leetcode206:
这里的反转链表，我们采取迭代的方法。从头开始遍历链表，由于反转过后的新链表最后一个指向null，
所以我们将原链表的结点一一赋值到新链表即可
struct ListNode* after = temp->next;
        temp->next = newHead;
        newHead = temp;
        temp = after;

leetcode92:
这道题要求对对应的区域范围的链表进行相反，
这个题目在206题的基础上，加上了我们需要定位这个需要取反的子链表范围。
并且在处理之后，我们需要将子链表的最后一个尾结点指向空指针，
并且处理好原来的链表前后两个结点，方便子链表取反之后还原到原链表上。

leetcode445:
这道题和高精加的题目差别在于链表需要反转，高精加的问题在于两个比较大的数相加，可能会导致int类型无法保存。
所以这里我们使用链表来保存数据，并且加以计算即可。高精加题目为leetcode2

leetcode21:
这道题要求我们将两个有序的链表进行合并，我们可以使用递归来做，